<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GhostMesh Dashboard</title>
    <script src="//unpkg.com/force-graph"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent: #38bdf8;
            --accent-hover: #0ea5e9;
            --border: #334155;
            --danger: #ef4444;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 2rem;
            line-height: 1.5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 1rem;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .status-badge {
            background-color: var(--card-bg);
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background-color: #22c55e;
            border-radius: 50%;
            box-shadow: 0 0 8px #22c55e;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 0.75rem;
            padding: 1.5rem;
            border: 1px solid var(--border);
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        h2 {
            margin-top: 0;
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: var(--text-secondary);
        }

        /* Tabs */
        .tab-container {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .tab-button {
            background: none;
            border: none;
            color: var(--text-secondary);
            padding: 0.75rem 1rem;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            position: relative;
        }

        .tab-button.active {
            color: var(--accent);
            border-bottom: 2px solid var(--accent);
        }

        .tab-button:hover {
            color: var(--text-primary);
        }

        .badge {
            background-color: var(--danger);
            color: white;
            font-size: 0.75rem;
            padding: 0.1rem 0.4rem;
            border-radius: 9999px;
            position: absolute;
            top: 0;
            right: 0;
            display: none;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #log-container,
        #dm-container {
            height: 300px;
            overflow-y: auto;
            background-color: #020617;
            border-radius: 0.5rem;
            padding: 1rem;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            border: 1px solid var(--border);
        }

        .log-entry {
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #1e293b;
        }

        .dm-entry {
            margin-bottom: 0.75rem;
            padding: 0.75rem;
            background-color: #1e293b;
            border-radius: 0.5rem;
            border-left: 3px solid var(--accent);
        }

        .dm-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .dm-content {
            color: var(--text-primary);
        }

        .input-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        input[type="text"] {
            flex: 1;
            background-color: #020617;
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            border-color: var(--accent);
        }

        button {
            background-color: var(--accent);
            color: #0f172a;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--accent-hover);
        }

        .peer-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .peer-tag {
            background-color: #334155;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.8rem;
            font-family: monospace;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div>
                <h1>GhostMesh Node</h1>
                <div id="local-peer-id"
                    style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.25rem; font-family: monospace;">
                    Loading ID...</div>
            </div>
            <div class="status-badge">
                <div class="status-dot"></div>
                <span id="peer-count">0 Peers Connected</span>
            </div>
        </header>

        <div class="card">
            <h2>Connected Peers</h2>
            <div id="peers-container" class="peer-list">
                <span style="color: var(--text-secondary);">Waiting for connections...</span>
            </div>
        </div>

        <div class="card">
            <div class="tab-container">
                <button class="tab-button active" onclick="switchTab('global')">Global Log</button>
                <button class="tab-button" onclick="switchTab('private')">
                    Private Messages
                    <span id="dm-badge" class="badge">0</span>
                </button>
                <button class="tab-button" onclick="switchTab('warroom')">War Room</button>
            </div>

            <div id="tab-global" class="tab-content active">
                <div id="log-container"></div>
                <div class="input-group">
                    <input type="text" id="log-input" placeholder="Type a message to broadcast..."
                        onkeypress="handleKeyPress(event)">
                    <button onclick="sendLog()">Send</button>
                </div>
            </div>

            <div id="tab-private" class="tab-content">
                <div id="dm-container">
                    <span style="color: var(--text-secondary);">No private messages yet.</span>
                </div>

                <div class="input-group"
                    style="margin-top: 1rem; border-top: 1px solid var(--border); padding-top: 1rem;">
                    <select id="dm-peer-select"
                        style="background-color: #020617; border: 1px solid var(--border); color: var(--text-primary); padding: 0.75rem; border-radius: 0.5rem; outline: none; min-width: 150px; flex-shrink: 0;">
                        <option value="">Select Peer...</option>
                    </select>
                    <input type="text" id="dm-input" placeholder="Type a private message..."
                        onkeypress="handleDmKeyPress(event)">
                    <button onclick="sendDm()">Send DM</button>
                </div>
            </div>

            <div id="tab-warroom" class="tab-content" style="position: relative;">
                <div id="graph-container"
                    style="background-color: #000; height: 400px; border-radius: 0.5rem; overflow: hidden; border: 1px solid var(--border);">
                </div>
                <button onclick="centerGraph()"
                    style="position: absolute; bottom: 1rem; right: 1rem; padding: 0.5rem; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; background-color: rgba(56, 189, 248, 0.2); border: 1px solid var(--accent); color: var(--accent); cursor: pointer; transition: all 0.2s;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10" />
                        <line x1="22" y1="12" x2="18" y2="12" />
                        <line x1="6" y1="12" x2="2" y2="12" />
                        <line x1="12" y1="6" x2="12" y2="2" />
                        <line x1="12" y1="22" x2="12" y2="18" />
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        let lastDmCount = 0;
        let isFirstLoad = true;
        let currentTab = 'global';

        function shortenId(id) {
            if (!id || id.length < 10) return id;
            return `${id.substring(0, 5)}...${id.substring(id.length - 5)}`;
        }

        function switchTab(tab) {
            currentTab = tab;

            // Update buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
                // Check if this button corresponds to the tab we are switching to
                // This is a bit hacky but works since we know the order or can pass 'this'
            });

            // Find the button that was clicked. 
            // Since we can't easily rely on event.target due to the badge, let's look for the button calling the function.
            // Actually, let's just use the fact that we have 3 specific tabs.
            const buttons = document.querySelectorAll('.tab-button');
            if (tab === 'global') buttons[0].classList.add('active');
            if (tab === 'private') buttons[1].classList.add('active');
            if (tab === 'warroom') buttons[2].classList.add('active');

            // Update content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');

            // Resize graph if switching to warroom
            if (tab === 'warroom') {
                setTimeout(() => {
                    const container = document.getElementById('graph-container');
                    Graph.width(container.clientWidth);
                    Graph.height(container.clientHeight);
                    Graph.zoomToFit(400);
                    setTimeout(() => centerGraph(), 500); // Center after zoomToFit
                }, 100);
            }

            // Clear badge if switching to private
            if (tab === 'private') {
                const badge = document.getElementById('dm-badge');
                badge.style.display = 'none';
                badge.innerText = '0';
            }
        }

        async function fetchState() {
            try {
                const response = await fetch('/api/state');
                const data = await response.json();

                // Update Local Peer ID
                if (data.local_peer_id) {
                    const shortened = shortenId(data.local_peer_id);
                    document.getElementById('local-peer-id').innerText = `ID: ${shortened}`;

                    // War Room: Set local ID and add to graph
                    if (!localPeerId) {
                        localPeerId = data.local_peer_id;
                        console.log('Local Peer ID set:', localPeerId);
                    }

                    // Ensure local node is in graph
                    if (!graphNodes.has(localPeerId)) {
                        graphNodes.add(localPeerId);
                    }

                    // Add existing peers to graph
                    if (data.peers && data.peers.length > 0) {
                        data.peers.forEach(peerId => {
                            if (!graphNodes.has(peerId)) {
                                console.log(`Adding existing peer to graph: ${peerId}`);
                                graphNodes.add(peerId);
                            }
                        });
                    }

                    // Backfill links (fix race condition)
                    let linksAdded = false;
                    graphNodes.forEach(peerId => {
                        if (peerId !== localPeerId) {
                            // Check if link exists (handle both raw strings and processed objects)
                            const exists = graphLinks.some(l => {
                                const s = l.source.id || l.source;
                                const t = l.target.id || l.target;
                                return (s === localPeerId && t === peerId) || (s === peerId && t === localPeerId);
                            });

                            if (!exists) {
                                console.log(`Backfilling link: ${localPeerId} <-> ${peerId}`);
                                graphLinks.push({ source: localPeerId, target: peerId });
                                linksAdded = true;
                            }
                        }
                    });

                    if (linksAdded) {
                        updateGraph();
                    }
                }

                // Update Peer Count
                document.getElementById('peer-count').innerText = `${data.peers.length} Peers Connected`;

                // Update Peer List
                const peersContainer = document.getElementById('peers-container');
                if (data.peers.length === 0) {
                    peersContainer.innerHTML = '<span style="color: var(--text-secondary);">Waiting for connections...</span>';
                } else {
                    peersContainer.innerHTML = data.peers.map(p => `<div class="peer-tag">${p}</div>`).join('');
                }

                // Update DM Peer Select (only if not focused to avoid interrupting user)
                const dmSelect = document.getElementById('dm-peer-select');
                if (document.activeElement !== dmSelect) {
                    const currentVal = dmSelect.value;
                    let options = '<option value="">Select Peer...</option>';
                    data.peers.forEach(p => {
                        const alias = shortenId(p);
                        options += `<option value="${p}" ${p === currentVal ? 'selected' : ''}>${alias}</option>`;
                    });
                    dmSelect.innerHTML = options;
                    dmSelect.value = currentVal; // Restore selection
                }

                // Update Global Log
                const logContainer = document.getElementById('log-container');
                const sortedLogs = data.log.sort();
                logContainer.innerHTML = sortedLogs.map(entry => `<div class="log-entry">${entry}</div>`).join('');

                // Update DMs
                const dmContainer = document.getElementById('dm-container');
                if (data.dms && data.dms.length > 0) {
                    dmContainer.innerHTML = data.dms.map(dm => {
                        const date = new Date(dm.timestamp * 1000).toLocaleString();
                        return `
                            <div class="dm-entry">
                                <div class="dm-header">
                                    <span>From: ${dm.from}</span>
                                    <span>${date}</span>
                                </div>
                                <div class="dm-content">${dm.content}</div>
                            </div>
                        `;
                    }).join('');
                } else {
                    dmContainer.innerHTML = '<span style="color: var(--text-secondary);">No private messages yet.</span>';
                }

                // Notifications
                // Notifications
                if (isFirstLoad) {
                    lastDmCount = data.dms ? data.dms.length : 0;
                    isFirstLoad = false;
                } else if (data.dms && data.dms.length > lastDmCount) {
                    const newCount = data.dms.length - lastDmCount;
                    if (currentTab !== 'private') {
                        const badge = document.getElementById('dm-badge');
                        const currentBadge = parseInt(badge.innerText) || 0;
                        badge.innerText = currentBadge + newCount;
                        badge.style.display = 'inline-block';
                    }
                    lastDmCount = data.dms.length;
                } else {
                    lastDmCount = data.dms ? data.dms.length : 0;
                }

            } catch (error) {
                console.error('Error fetching state:', error);
            }
        }

        async function sendLog() {
            const input = document.getElementById('log-input');
            const msg = input.value.trim();
            if (!msg) return;

            try {
                await fetch('/api/log', {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: msg
                });
                input.value = '';
                fetchState();
            } catch (error) {
                console.error('Error sending log:', error);
            }
        }

        async function sendDm() {
            const select = document.getElementById('dm-peer-select');
            const input = document.getElementById('dm-input');
            const to = select.value;
            const content = input.value.trim();

            if (!to || !content) {
                alert("Please select a peer and type a message.");
                return;
            }

            try {
                await fetch('/api/dm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ to, content })
                });
                input.value = '';
                alert("DM Sent!");
            } catch (error) {
                console.error('Error sending DM:', error);
                alert("Failed to send DM.");
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendLog();
            }
        }

        function handleDmKeyPress(event) {
            if (event.key === 'Enter') {
                sendDm();
            }
        }

        // Poll every 1 second
        setInterval(fetchState, 1000);
        fetchState();

        // --- War Room Logic ---
        const Graph = ForceGraph()
            (document.getElementById('graph-container'))
            .graphData({ nodes: [], links: [] })
            .nodeLabel(node => {
                const id = node.id;
                if (!id || id.length < 5) return id;
                return `#${id.substring(id.length - 5)}`;
            })
            .nodeRelSize(3) // Smaller nodes (default is 4)
            .nodeColor(node => node.id === localPeerId ? '#38bdf8' : '#22c55e')
            .linkColor(() => '#334155')
            .linkDirectionalParticleColor(() => '#ffff00') // Yellow particles
            .linkDirectionalParticleWidth(4) // Thicker particles
            .linkDirectionalParticleSpeed(0.01) // Slower speed
            .backgroundColor('#000000');

        // Center graph on load/resize
        Graph.centerAt(0, 0);

        let localPeerId = null;
        let graphNodes = new Set();
        let graphLinks = [];

        function centerGraph() {
            // Find local node position
            const node = Graph.graphData().nodes.find(n => n.id === localPeerId);
            if (node) {
                Graph.centerAt(node.x, node.y, 1000);
                Graph.zoom(1.5, 2000);
            } else {
                Graph.centerAt(0, 0, 1000);
                Graph.zoom(1, 2000);
            }
        }

        function updateGraph() {
            const nodes = Array.from(graphNodes).map(id => {
                // We don't fix the position anymore, just let it float
                return { id };
            });
            Graph.graphData({ nodes, links: graphLinks });
        }

        // WebSocket Connection
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws`;
        const ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            console.log('Connected to Telemetry WebSocket');
        };

        ws.onmessage = (event) => {
            console.log('RAW WS DATA:', event.data); // Debug raw data
            try {
                const msg = JSON.parse(event.data);
                console.log('Telemetry:', msg);

                if (msg.type === 'PeerConnected') {
                    const peerId = msg.data.peer_id;
                    if (!graphNodes.has(peerId)) {
                        graphNodes.add(peerId);
                        // Link to local node (star topology for now as we only see direct connections)
                        if (localPeerId) {
                            graphLinks.push({ source: localPeerId, target: peerId });
                        }
                        updateGraph();
                    }
                } else if (msg.type === 'PeerDisconnected') {
                    const peerId = msg.data.peer_id;
                    if (graphNodes.has(peerId)) {
                        graphNodes.delete(peerId);
                        graphLinks = graphLinks.filter(l => l.source.id !== peerId && l.target.id !== peerId);
                        updateGraph();
                    }
                } else if (msg.type === 'MessageSent' || msg.type === 'MessageReceived') {
                    const { from, to } = msg.data;
                    console.log(`Event ${msg.type}: ${from} -> ${to}`);

                    // Helper to handle both string IDs and Node Objects
                    const getId = (n) => n.id || n;

                    // Ensure nodes exist
                    if (!graphNodes.has(from)) {
                        console.log(`Auto-adding missing node: ${from}`);
                        graphNodes.add(from);
                        updateGraph();
                    }
                    if (!graphNodes.has(to)) {
                        console.log(`Auto-adding missing node: ${to}`);
                        graphNodes.add(to);
                        updateGraph();
                    }

                    // Find link
                    let link = graphLinks.find(l => {
                        const s = getId(l.source);
                        const t = getId(l.target);
                        return (s === from && t === to) || (s === to && t === from);
                    });

                    if (!link) {
                        console.warn('Link NOT found. Creating it now...');
                        link = { source: from, target: to };
                        graphLinks.push(link);
                        updateGraph();
                        // We need to wait for the graph to process the new link before emitting? 
                        // Usually force-graph updates are fast, but let's try emitting immediately.
                        // If it fails, the particle just won't show, but the link will appear.
                    }

                    if (link) {
                        console.log('Emitting particle on link:', link);
                        // Small delay to ensure link is rendered if just added
                        setTimeout(() => Graph.emitParticle(link), 100);
                    }

                    // Visual feedback (Toast)
                    const toast = document.createElement('div');
                    toast.style.position = 'fixed';
                    toast.style.bottom = '20px';
                    toast.style.right = '20px';
                    toast.style.backgroundColor = '#38bdf8';
                    toast.style.color = '#000';
                    toast.style.padding = '10px 20px';
                    toast.style.borderRadius = '5px';
                    toast.style.zIndex = '1000';
                    toast.innerText = `Packet: ${shortenId(from)} -> ${shortenId(to)}`;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 3000);
                }
            } catch (e) {
                console.error('WS Error:', e);
            }
        };

    </script>
</body>

</html>